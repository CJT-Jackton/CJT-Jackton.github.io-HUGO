+++ 
date = 2020-05-23T10:43:59+08:00
title = "Shader Breakdown - LCD Display"
description = "Breakdown of the LCD display shader."
slug = "" 
tags = ["Shader", "Unity", "Universal Render Pipeline"]
categories = []
externalLink = ""
series = []
+++

{{< figure src="/images/shader-breakdown-lcd-display/Shader-Breakdown-LCD-Display.png" >}}

This post is the breakdown of LCD display shader. Source code for Unity URP is provided.

> {{< fab github >}} Github \
> [Source Code](https://github.com/CJT-Jackton/URP-LCD-Dispaly-Example)

So after reading this [shader tutorial](https://www.alanzucconi.com/2016/05/04/lcd-shader/) by Alan Zucconi, I decided to make my own version of LCD display shader. Without further ado, let's get straight into it. This effect itself quiet simple, when viewing from distance, the LCD display act identical as a standard emissive material. But once you move close enough to the display, you can see the individual pixels of the LCD screen.

---

### Pixelize Display Content

When you magnify the texture, you will notice that the texture become blurrer. That's because the texture is using [Bilinear filtering](https://en.wikipedia.org/wiki/Bilinear_interpolation). When grabbing one point on the texture, four nearest pixels value were sampled and interpolated base on the distance. However on the actual display, each display pixel can only emit exact one color. So general speaking the texture of display content should use Point filtering to keep the pixel grid when magnify, but Point filtering also cause some sampling artifacts since the sampling point can't always lands exactly on the position of one pixel. Is there a way to keep using Bilinear filtering and making the texture pixelize when close-up?

And yes there is. We can manipulate the uv coordinate to trick the texture filtering. Using `floor()` returning the biggest integer that smaller than the texture coordinate, we can snap to the position of the nearest pixel to sampling point.

```hlsl
float2 pixelMaskUV = uv * _BaseMap_TexelSize.zw;
float2 pixelizedUV = floor(pixelMaskUV) + float2(0.5, 0.5);
pixelizedUV /= _BaseMap_TexelSize.zw;
```

You can also use `ceil()` or `round()`, they are functionally same here. Now we just need to know when to use the normal uv coordinate and when to use the manipulated coordinate. Hold on a second, we gonna figure it out in the following section.

---

### LCD Display Pixel

So first off, we will need a texture that represents the actual pixel of display. A quick google search of "LCD pixel" will do the trick for you. Note that that is some displays that have none standard layout, like Pentile style display, but we won't get into these and only stick with the normal RGB pixel layout for the sake of simplicity of this tutorial.

We want to know the dimensions of the texture we using as the display content, and use it to scale the uv coordinate so that the pixel tile on each pixel of the texture. In Unity, you can call `TextureName_TexelSize` and Unity will automatically set up the right value for you.

``` hlsl
float2 pixelMaskUV = input.uv * _BaseMap_TexelSize.zw;
```

Then we simply multiply the LCD pixel texture and the color sampled from the display content texture.

You might immediately notice that the display become dim. The reason why is we multiplied the color with the pixel texture, however each color channel only occupied less than 1/3 of the pixel grid, so we lost over 2/3 of the luminance. We can compensate the lost brightness by multiply a multiplier. You can find out the right value of your pixel texture in Photoshop's histogram view. Take my texture as example, the average value of red, green, blue is around 63 hence the multipier should be 255/63 = 4. 

Also, the texture seems to has some weird color shift while viewing from certain distance. That is cause by some undesired artifacts of the automatic generated texture mipmap. It is very clear in the figure down below. The 5th level of the mipmap is completely turns into another color that we don't really want.

{{< figure src="/images/shader-breakdown-lcd-display/pixel-mipmap.png" caption="Each mipmap level generated by Unity. Take a look on Mip 5, you can see why it is causing trouble." >}}

We need a way to figure out the right texture mipmap level.

---

### Manually Compute Mipmap Level

First we need to know how texture lod level is calculated on the graphic side. The [OpenGL specification](https://www.khronos.org/registry/OpenGL/specs/gl/glspec42.core.pdf) actually give us a clue of how this is done. In the chapter 3.9.11 we have the following equation:

\\[
\lambda(x, y) = \log_2{\\big(\rho(x, y)\\big)}
\\]

where \\(\lambda\\) is the level-of-detail parameter, and \\(\rho(x, y)\\) is a scale factor such that:

\\[
\rho = max \\Bigg\\{ \sqrt{\\Big(\frac{\partial{u}}{\partial{x}}\\Big)^{2} + \\Big(\frac{\partial{v}}{\partial{x}}\\Big)^{2} + \\Big(\frac{\partial{w}}{\partial{x}}\\Big)^{2}}, \sqrt{\\Big(\frac{\partial{u}}{\partial{y}}\\Big)^{2} + \\Big(\frac{\partial{v}}{\partial{y}}\\Big)^{2} + \\Big(\frac{\partial{w}}{\partial{y}}\\Big)^{2}} \\Bigg\\}
\\]

Okay, the partial derivative might looks scary at the first glance. Let's break it down step by step. The \\(\partial{u} / \partial{x}\\) indicates the derivative of \\(u\\) with respect to window \\(x\\), put it in another word, the change rate of texture coordinate between screen pixel currently evaluating and the adjacent pixel on the right. Note that the \\(u\\) and \\(v\\) values here aren't normalized. Take a 512\\(\times\\)512 texture as example, the texture coordinate of the center of the texture is expected to be (256, 256) instead of (0.5, 0.5). The square root of the sum of squares of derivative of \\(u\\) and \\(v\\) equals . Finally we compute the binary logarithmic of the scale factor. That actually make sense since we know that the texture size is halved each mipmap level down!

We can move the square root out of binary logarithmic saving us some instructions, and the equation become:

\\[
\lambda(x, y) = 0.5 \times \log_{2}{\\Bigg( max \\bigg\\{ \\Big(\frac{\partial{u}}{\partial{x}}\\Big)^{2} + \\Big(\frac{\partial{v}}{\partial{x}}\\Big)^{2}, \\Big(\frac{\partial{u}}{\partial{y}}\\Big)^{2} + \\Big(\frac{\partial{v}}{\partial{y}}\\Big)^{2} \\bigg\\}\\Bigg)}
\\]

Converting into HLSL code.

```hlsl
// The OpenGL Graphics System: A Specification 4.2
//  - chapter 3.9.11, equation 3.21
float2 pixelMaskTexcoord = pixelMaskUV * _PixelMask_TexelSize.zw;

float2 duvdx = ddx(pixelMaskTexcoord);
float2 duvdy = ddy(pixelMaskTexcoord);

float scaleFactor = max(dot(duvdx, duvdx), dot(duvdy, duvdy));
float mipmapLevel = 0.5 * log2(scaleFactor);
```

> **Why don't use `CalculateLevelOfDetail`?**
>
> Well there is nothing to stopping you use `CalculateLevelOfDetail` instead of `ComputeTextureLOD` in your code, however, keep in mind that using it will require shader model 5.0 which isn't always wanted due to compatibility issue.

---

### Interpolate Between Mipmap Level

Now we can interpolate between the normal texture and pixelized texture with texture lod value. The texture lod value needs to be remap to [0, 1]. 

Finally, to add some finishing touches, you can implement some glitch effect that quite common in the old television.

---

### Conclusion

That's it for this small breakdown of LCD display shader, hope you learn something about derivative in fragment shader and texture lod (I certainly do). You can find the full [source code](https://github.com/CJT-Jackton/URP-LCD-Dispaly-Example) on my Github. Also I put the link to the original shader tutorial by Alan Zucconi down below, and a similar article by Austin O'brien that definitely worth reading.

**{{< fas link >}}&nbsp; Other Useful Resources**
> Alan Zucconi \
> [LCD Display Shader Effect](https://www.alanzucconi.com/2016/05/04/lcd-shader/)

> Austin O'brien \
> [Slime Rancher Pixel Display](https://www.austinobrien.me/blog/shader-study/slime-rancher-pixel-display)


{{< figure src="/images/kiki-footer.png" >}}